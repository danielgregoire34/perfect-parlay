{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport { assertInterfaceType, assertNullableType, assertObjectType, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isInputType, isOutputType } from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\r\n * Build a GraphQLSchema for use by client tools.\r\n *\r\n * Given the result of a client running the introspection query, creates and\r\n * returns a GraphQLSchema instance which can be then used with all graphql-js\r\n * tools, but cannot be used to execute a query, as introspection does not\r\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\r\n * server-internal mechanisms.\r\n *\r\n * This function expects a complete introspection result. Don't forget to check\r\n * the \"errors\" field of a server response before calling this function.\r\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(introspection)}.`); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(schemaIntrospection.types, typeIntrospection => typeIntrospection.name, typeIntrospection => buildType(typeIntrospection)); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n    return getNamedType(typeRef);\n  }\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n    const type = typeMap[typeName];\n    if (!type) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n    return type;\n  }\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    const typeStr = inspect(type);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, valueIntrospection => valueIntrospection.name, valueIntrospection => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${inspect(typeIntrospection)}.`);\n    }\n    return keyValMap(typeIntrospection.fields, fieldIntrospection => fieldIntrospection.name, buildField);\n  }\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, inputValue => inputValue.name, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["devAssert","inspect","isObjectLike","keyValMap","parseValue","assertInterfaceType","assertNullableType","assertObjectType","GraphQLEnumType","GraphQLInputObjectType","GraphQLInterfaceType","GraphQLList","GraphQLNonNull","GraphQLObjectType","GraphQLScalarType","GraphQLUnionType","isInputType","isOutputType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","GraphQLSchema","valueFromAST","buildClientSchema","introspection","options","__schema","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","Object","values","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","isRepeatable","slice"],"sources":["C:/Users/Daniel Gregoire/Desktop/ucf-bootcamp/perfect-parlay/client/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\r\nimport { parseValue } from '../language/parser.mjs';\r\nimport {\r\n  assertInterfaceType,\r\n  assertNullableType,\r\n  assertObjectType,\r\n  GraphQLEnumType,\r\n  GraphQLInputObjectType,\r\n  GraphQLInterfaceType,\r\n  GraphQLList,\r\n  GraphQLNonNull,\r\n  GraphQLObjectType,\r\n  GraphQLScalarType,\r\n  GraphQLUnionType,\r\n  isInputType,\r\n  isOutputType,\r\n} from '../type/definition.mjs';\r\nimport { GraphQLDirective } from '../type/directives.mjs';\r\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\r\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\r\nimport { GraphQLSchema } from '../type/schema.mjs';\r\nimport { valueFromAST } from './valueFromAST.mjs';\r\n/**\r\n * Build a GraphQLSchema for use by client tools.\r\n *\r\n * Given the result of a client running the introspection query, creates and\r\n * returns a GraphQLSchema instance which can be then used with all graphql-js\r\n * tools, but cannot be used to execute a query, as introspection does not\r\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\r\n * server-internal mechanisms.\r\n *\r\n * This function expects a complete introspection result. Don't forget to check\r\n * the \"errors\" field of a server response before calling this function.\r\n */\r\n\r\nexport function buildClientSchema(introspection, options) {\r\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\r\n    devAssert(\r\n      false,\r\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\r\n        introspection,\r\n      )}.`,\r\n    ); // Get the schema from the introspection result.\r\n\r\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\r\n\r\n  const typeMap = keyValMap(\r\n    schemaIntrospection.types,\r\n    (typeIntrospection) => typeIntrospection.name,\r\n    (typeIntrospection) => buildType(typeIntrospection),\r\n  ); // Include standard types only if they are used.\r\n\r\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\r\n    if (typeMap[stdType.name]) {\r\n      typeMap[stdType.name] = stdType;\r\n    }\r\n  } // Get the root Query, Mutation, and Subscription types.\r\n\r\n  const queryType = schemaIntrospection.queryType\r\n    ? getObjectType(schemaIntrospection.queryType)\r\n    : null;\r\n  const mutationType = schemaIntrospection.mutationType\r\n    ? getObjectType(schemaIntrospection.mutationType)\r\n    : null;\r\n  const subscriptionType = schemaIntrospection.subscriptionType\r\n    ? getObjectType(schemaIntrospection.subscriptionType)\r\n    : null; // Get the directives supported by Introspection, assuming empty-set if\r\n  // directives were not queried for.\r\n\r\n  const directives = schemaIntrospection.directives\r\n    ? schemaIntrospection.directives.map(buildDirective)\r\n    : []; // Then produce and return a Schema with these types.\r\n\r\n  return new GraphQLSchema({\r\n    description: schemaIntrospection.description,\r\n    query: queryType,\r\n    mutation: mutationType,\r\n    subscription: subscriptionType,\r\n    types: Object.values(typeMap),\r\n    directives,\r\n    assumeValid:\r\n      options === null || options === void 0 ? void 0 : options.assumeValid,\r\n  }); // Given a type reference in introspection, return the GraphQLType instance.\r\n  // preferring cached instances before building new instances.\r\n\r\n  function getType(typeRef) {\r\n    if (typeRef.kind === TypeKind.LIST) {\r\n      const itemRef = typeRef.ofType;\r\n\r\n      if (!itemRef) {\r\n        throw new Error('Decorated type deeper than introspection query.');\r\n      }\r\n\r\n      return new GraphQLList(getType(itemRef));\r\n    }\r\n\r\n    if (typeRef.kind === TypeKind.NON_NULL) {\r\n      const nullableRef = typeRef.ofType;\r\n\r\n      if (!nullableRef) {\r\n        throw new Error('Decorated type deeper than introspection query.');\r\n      }\r\n\r\n      const nullableType = getType(nullableRef);\r\n      return new GraphQLNonNull(assertNullableType(nullableType));\r\n    }\r\n\r\n    return getNamedType(typeRef);\r\n  }\r\n\r\n  function getNamedType(typeRef) {\r\n    const typeName = typeRef.name;\r\n\r\n    if (!typeName) {\r\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\r\n    }\r\n\r\n    const type = typeMap[typeName];\r\n\r\n    if (!type) {\r\n      throw new Error(\r\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\r\n      );\r\n    }\r\n\r\n    return type;\r\n  }\r\n\r\n  function getObjectType(typeRef) {\r\n    return assertObjectType(getNamedType(typeRef));\r\n  }\r\n\r\n  function getInterfaceType(typeRef) {\r\n    return assertInterfaceType(getNamedType(typeRef));\r\n  } // Given a type's introspection result, construct the correct\r\n  // GraphQLType instance.\r\n\r\n  function buildType(type) {\r\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\r\n    if (type != null && type.name != null && type.kind != null) {\r\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\r\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n      switch (type.kind) {\r\n        case TypeKind.SCALAR:\r\n          return buildScalarDef(type);\r\n\r\n        case TypeKind.OBJECT:\r\n          return buildObjectDef(type);\r\n\r\n        case TypeKind.INTERFACE:\r\n          return buildInterfaceDef(type);\r\n\r\n        case TypeKind.UNION:\r\n          return buildUnionDef(type);\r\n\r\n        case TypeKind.ENUM:\r\n          return buildEnumDef(type);\r\n\r\n        case TypeKind.INPUT_OBJECT:\r\n          return buildInputObjectDef(type);\r\n      }\r\n    }\r\n\r\n    const typeStr = inspect(type);\r\n    throw new Error(\r\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\r\n    );\r\n  }\r\n\r\n  function buildScalarDef(scalarIntrospection) {\r\n    return new GraphQLScalarType({\r\n      name: scalarIntrospection.name,\r\n      description: scalarIntrospection.description,\r\n      specifiedByURL: scalarIntrospection.specifiedByURL,\r\n    });\r\n  }\r\n\r\n  function buildImplementationsList(implementingIntrospection) {\r\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\r\n    // 'interfaces' on interface types.\r\n    if (\r\n      implementingIntrospection.interfaces === null &&\r\n      implementingIntrospection.kind === TypeKind.INTERFACE\r\n    ) {\r\n      return [];\r\n    }\r\n\r\n    if (!implementingIntrospection.interfaces) {\r\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return implementingIntrospection.interfaces.map(getInterfaceType);\r\n  }\r\n\r\n  function buildObjectDef(objectIntrospection) {\r\n    return new GraphQLObjectType({\r\n      name: objectIntrospection.name,\r\n      description: objectIntrospection.description,\r\n      interfaces: () => buildImplementationsList(objectIntrospection),\r\n      fields: () => buildFieldDefMap(objectIntrospection),\r\n    });\r\n  }\r\n\r\n  function buildInterfaceDef(interfaceIntrospection) {\r\n    return new GraphQLInterfaceType({\r\n      name: interfaceIntrospection.name,\r\n      description: interfaceIntrospection.description,\r\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\r\n      fields: () => buildFieldDefMap(interfaceIntrospection),\r\n    });\r\n  }\r\n\r\n  function buildUnionDef(unionIntrospection) {\r\n    if (!unionIntrospection.possibleTypes) {\r\n      const unionIntrospectionStr = inspect(unionIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return new GraphQLUnionType({\r\n      name: unionIntrospection.name,\r\n      description: unionIntrospection.description,\r\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\r\n    });\r\n  }\r\n\r\n  function buildEnumDef(enumIntrospection) {\r\n    if (!enumIntrospection.enumValues) {\r\n      const enumIntrospectionStr = inspect(enumIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return new GraphQLEnumType({\r\n      name: enumIntrospection.name,\r\n      description: enumIntrospection.description,\r\n      values: keyValMap(\r\n        enumIntrospection.enumValues,\r\n        (valueIntrospection) => valueIntrospection.name,\r\n        (valueIntrospection) => ({\r\n          description: valueIntrospection.description,\r\n          deprecationReason: valueIntrospection.deprecationReason,\r\n        }),\r\n      ),\r\n    });\r\n  }\r\n\r\n  function buildInputObjectDef(inputObjectIntrospection) {\r\n    if (!inputObjectIntrospection.inputFields) {\r\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return new GraphQLInputObjectType({\r\n      name: inputObjectIntrospection.name,\r\n      description: inputObjectIntrospection.description,\r\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\r\n    });\r\n  }\r\n\r\n  function buildFieldDefMap(typeIntrospection) {\r\n    if (!typeIntrospection.fields) {\r\n      throw new Error(\r\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\r\n      );\r\n    }\r\n\r\n    return keyValMap(\r\n      typeIntrospection.fields,\r\n      (fieldIntrospection) => fieldIntrospection.name,\r\n      buildField,\r\n    );\r\n  }\r\n\r\n  function buildField(fieldIntrospection) {\r\n    const type = getType(fieldIntrospection.type);\r\n\r\n    if (!isOutputType(type)) {\r\n      const typeStr = inspect(type);\r\n      throw new Error(\r\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\r\n      );\r\n    }\r\n\r\n    if (!fieldIntrospection.args) {\r\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return {\r\n      description: fieldIntrospection.description,\r\n      deprecationReason: fieldIntrospection.deprecationReason,\r\n      type,\r\n      args: buildInputValueDefMap(fieldIntrospection.args),\r\n    };\r\n  }\r\n\r\n  function buildInputValueDefMap(inputValueIntrospections) {\r\n    return keyValMap(\r\n      inputValueIntrospections,\r\n      (inputValue) => inputValue.name,\r\n      buildInputValue,\r\n    );\r\n  }\r\n\r\n  function buildInputValue(inputValueIntrospection) {\r\n    const type = getType(inputValueIntrospection.type);\r\n\r\n    if (!isInputType(type)) {\r\n      const typeStr = inspect(type);\r\n      throw new Error(\r\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\r\n      );\r\n    }\r\n\r\n    const defaultValue =\r\n      inputValueIntrospection.defaultValue != null\r\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\r\n        : undefined;\r\n    return {\r\n      description: inputValueIntrospection.description,\r\n      type,\r\n      defaultValue,\r\n      deprecationReason: inputValueIntrospection.deprecationReason,\r\n    };\r\n  }\r\n\r\n  function buildDirective(directiveIntrospection) {\r\n    if (!directiveIntrospection.args) {\r\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    if (!directiveIntrospection.locations) {\r\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\r\n      throw new Error(\r\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\r\n      );\r\n    }\r\n\r\n    return new GraphQLDirective({\r\n      name: directiveIntrospection.name,\r\n      description: directiveIntrospection.description,\r\n      isRepeatable: directiveIntrospection.isRepeatable,\r\n      locations: directiveIntrospection.locations.slice(),\r\n      args: buildInputValueDefMap(directiveIntrospection.args),\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}