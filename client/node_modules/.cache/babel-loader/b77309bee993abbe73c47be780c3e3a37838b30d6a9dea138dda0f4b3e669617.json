{"ast":null,"code":"import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\r\n * Configuration options to control parser behavior\r\n */\n\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\n\nexport class Parser {\n  constructor(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\r\n   * Document : Definition+\r\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n    });\n  }\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   *\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n        case 'type':\n          return this.parseObjectTypeDefinition();\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n        case 'union':\n          return this.parseUnionTypeDefinition();\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n      if (hasDescription) {\n        throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n      }\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n        case 'fragment':\n          return this.parseFragmentDefinition();\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    const operation = this.parseOperationType();\n    let name;\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n    throw this.unexpected(operationToken);\n  }\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n      directives: this.parseConstDirectives()\n    });\n  }\n  /**\r\n   * Variable : $ Name\r\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  /**\r\n   * ```\r\n   * SelectionSet : { Selection+ }\r\n   * ```\r\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n    });\n  }\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n    });\n  }\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\n\n  parseArgument() {\n    let isConst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value\n        });\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value\n        });\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n      case TokenKind.NAME:\n        this.advanceLexer();\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true\n            });\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false\n            });\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL\n            });\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value\n            });\n        }\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(this._lexer.source, token.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n        return this.parseVariable();\n      default:\n        throw this.unexpected();\n    }\n  }\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING\n    });\n  }\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n    });\n  }\n  /**\r\n   * ```\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   * ```\r\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n    });\n  }\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n    return directives;\n  }\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\r\n   * ```\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   * ```\r\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type\n      });\n    }\n    return type;\n  }\n  /**\r\n   * NamedType : Name\r\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\r\n   * Description : StringValue\r\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\r\n   * ```\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   * ```\r\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type\n    });\n  }\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n  }\n  /**\r\n   * ```\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   * ```\r\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives\n    });\n  }\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives\n    });\n  }\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\r\n   * ```\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   * ```\r\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\n\n  parseEnumValueName() {\n    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n    return this.parseName();\n  }\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ```\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   * ```\r\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n        case 'type':\n          return this.parseObjectTypeExtension();\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n        case 'union':\n          return this.parseUnionTypeExtension();\n        case 'enum':\n          return this.parseEnumTypeExtension();\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  }\n  /**\r\n   * ```\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   * ```\r\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives\n    });\n  }\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\r\n   * ```\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   * ```\r\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\r\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n   * location object, used to identify the place in the source that created a\r\n   * given parsed object.\r\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n    return node;\n  }\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);\n  }\n  /**\r\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, `Expected \"${value}\", found ${getTokenDesc(token)}.`);\n    }\n  }\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n    return false;\n  }\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\n\n  unexpected(atToken) {\n    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);\n  }\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n    return nodes;\n  }\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    return [];\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n    return nodes;\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n    return nodes;\n  }\n  advanceLexer() {\n    const {\n      maxTokens\n    } = this._options;\n    const token = this._lexer.advance();\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);\n      }\n    }\n  }\n}\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}","map":{"version":3,"names":["syntaxError","Location","OperationTypeNode","DirectiveLocation","Kind","isPunctuatorTokenKind","Lexer","isSource","Source","TokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseConstValue","parseConstValueLiteral","parseType","type","parseTypeReference","constructor","arguments","length","undefined","sourceObj","_lexer","_options","_tokenCounter","parseName","token","NAME","node","kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","name","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advanceLexer","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","Object","prototype","hasOwnProperty","call","startToken","noLocation","loc","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","maxTokens","advance"],"sources":["C:/Users/Daniel Gregoire/Desktop/ucf-bootcamp/perfect-parlay/client/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\r\nimport { Location, OperationTypeNode } from './ast.mjs';\r\nimport { DirectiveLocation } from './directiveLocation.mjs';\r\nimport { Kind } from './kinds.mjs';\r\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\r\nimport { isSource, Source } from './source.mjs';\r\nimport { TokenKind } from './tokenKind.mjs';\r\n/**\r\n * Configuration options to control parser behavior\r\n */\r\n\r\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\r\nexport function parse(source, options) {\r\n  const parser = new Parser(source, options);\r\n  return parser.parseDocument();\r\n}\r\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\r\n\r\nexport function parseValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseValueLiteral(false);\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\r\n\r\nexport function parseConstValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseConstValueLiteral();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\r\n\r\nexport function parseType(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const type = parser.parseTypeReference();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return type;\r\n}\r\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\r\n\r\nexport class Parser {\r\n  constructor(source, options = {}) {\r\n    const sourceObj = isSource(source) ? source : new Source(source);\r\n    this._lexer = new Lexer(sourceObj);\r\n    this._options = options;\r\n    this._tokenCounter = 0;\r\n  }\r\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\r\n\r\n  parseName() {\r\n    const token = this.expectToken(TokenKind.NAME);\r\n    return this.node(token, {\r\n      kind: Kind.NAME,\r\n      value: token.value,\r\n    });\r\n  } // Implements the parsing rules in the Document section.\r\n\r\n  /**\r\n   * Document : Definition+\r\n   */\r\n\r\n  parseDocument() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.DOCUMENT,\r\n      definitions: this.many(\r\n        TokenKind.SOF,\r\n        this.parseDefinition,\r\n        TokenKind.EOF,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   *\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseDefinition() {\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.parseOperationDefinition();\r\n    } // Many definitions begin with a description and require a lookahead.\r\n\r\n    const hasDescription = this.peekDescription();\r\n    const keywordToken = hasDescription\r\n      ? this._lexer.lookahead()\r\n      : this._lexer.token;\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaDefinition();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeDefinition();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeDefinition();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeDefinition();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeDefinition();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeDefinition();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeDefinition();\r\n\r\n        case 'directive':\r\n          return this.parseDirectiveDefinition();\r\n      }\r\n\r\n      if (hasDescription) {\r\n        throw syntaxError(\r\n          this._lexer.source,\r\n          this._lexer.token.start,\r\n          'Unexpected description, descriptions are supported only on type definitions.',\r\n        );\r\n      }\r\n\r\n      switch (keywordToken.value) {\r\n        case 'query':\r\n        case 'mutation':\r\n        case 'subscription':\r\n          return this.parseOperationDefinition();\r\n\r\n        case 'fragment':\r\n          return this.parseFragmentDefinition();\r\n\r\n        case 'extend':\r\n          return this.parseTypeSystemExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  } // Implements the parsing rules in the Operations section.\r\n\r\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\r\n\r\n  parseOperationDefinition() {\r\n    const start = this._lexer.token;\r\n\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.node(start, {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: OperationTypeNode.QUERY,\r\n        name: undefined,\r\n        variableDefinitions: [],\r\n        directives: [],\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    const operation = this.parseOperationType();\r\n    let name;\r\n\r\n    if (this.peek(TokenKind.NAME)) {\r\n      name = this.parseName();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_DEFINITION,\r\n      operation,\r\n      name,\r\n      variableDefinitions: this.parseVariableDefinitions(),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\r\n\r\n  parseOperationType() {\r\n    const operationToken = this.expectToken(TokenKind.NAME);\r\n\r\n    switch (operationToken.value) {\r\n      case 'query':\r\n        return OperationTypeNode.QUERY;\r\n\r\n      case 'mutation':\r\n        return OperationTypeNode.MUTATION;\r\n\r\n      case 'subscription':\r\n        return OperationTypeNode.SUBSCRIPTION;\r\n    }\r\n\r\n    throw this.unexpected(operationToken);\r\n  }\r\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\r\n\r\n  parseVariableDefinitions() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseVariableDefinition,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseVariableDefinition() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.VARIABLE_DEFINITION,\r\n      variable: this.parseVariable(),\r\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\r\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\r\n        ? this.parseConstValueLiteral()\r\n        : undefined,\r\n      directives: this.parseConstDirectives(),\r\n    });\r\n  }\r\n  /**\r\n   * Variable : $ Name\r\n   */\r\n\r\n  parseVariable() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.DOLLAR);\r\n    return this.node(start, {\r\n      kind: Kind.VARIABLE,\r\n      name: this.parseName(),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * SelectionSet : { Selection+ }\r\n   * ```\r\n   */\r\n\r\n  parseSelectionSet() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.SELECTION_SET,\r\n      selections: this.many(\r\n        TokenKind.BRACE_L,\r\n        this.parseSelection,\r\n        TokenKind.BRACE_R,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\r\n\r\n  parseSelection() {\r\n    return this.peek(TokenKind.SPREAD)\r\n      ? this.parseFragment()\r\n      : this.parseField();\r\n  }\r\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\r\n\r\n  parseField() {\r\n    const start = this._lexer.token;\r\n    const nameOrAlias = this.parseName();\r\n    let alias;\r\n    let name;\r\n\r\n    if (this.expectOptionalToken(TokenKind.COLON)) {\r\n      alias = nameOrAlias;\r\n      name = this.parseName();\r\n    } else {\r\n      name = nameOrAlias;\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FIELD,\r\n      alias,\r\n      name,\r\n      arguments: this.parseArguments(false),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.peek(TokenKind.BRACE_L)\r\n        ? this.parseSelectionSet()\r\n        : undefined,\r\n    });\r\n  }\r\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\r\n\r\n  parseArguments(isConst) {\r\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\r\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseArgument(isConst = false) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.ARGUMENT,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  }\r\n\r\n  parseConstArgument() {\r\n    return this.parseArgument(true);\r\n  } // Implements the parsing rules in the Fragments section.\r\n\r\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\r\n\r\n  parseFragment() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.SPREAD);\r\n    const hasTypeCondition = this.expectOptionalKeyword('on');\r\n\r\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_SPREAD,\r\n        name: this.parseFragmentName(),\r\n        directives: this.parseDirectives(false),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INLINE_FRAGMENT,\r\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\r\n\r\n  parseFragmentDefinition() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\r\n    // the grammar of FragmentDefinition:\r\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\r\n\r\n    if (this._options.allowLegacyFragmentVariables === true) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_DEFINITION,\r\n        name: this.parseFragmentName(),\r\n        variableDefinitions: this.parseVariableDefinitions(),\r\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n        directives: this.parseDirectives(false),\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FRAGMENT_DEFINITION,\r\n      name: this.parseFragmentName(),\r\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\r\n\r\n  parseFragmentName() {\r\n    if (this._lexer.token.value === 'on') {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.parseName();\r\n  } // Implements the parsing rules in the Values section.\r\n\r\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseValueLiteral(isConst) {\r\n    const token = this._lexer.token;\r\n\r\n    switch (token.kind) {\r\n      case TokenKind.BRACKET_L:\r\n        return this.parseList(isConst);\r\n\r\n      case TokenKind.BRACE_L:\r\n        return this.parseObject(isConst);\r\n\r\n      case TokenKind.INT:\r\n        this.advanceLexer();\r\n        return this.node(token, {\r\n          kind: Kind.INT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.FLOAT:\r\n        this.advanceLexer();\r\n        return this.node(token, {\r\n          kind: Kind.FLOAT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.STRING:\r\n      case TokenKind.BLOCK_STRING:\r\n        return this.parseStringLiteral();\r\n\r\n      case TokenKind.NAME:\r\n        this.advanceLexer();\r\n\r\n        switch (token.value) {\r\n          case 'true':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: true,\r\n            });\r\n\r\n          case 'false':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: false,\r\n            });\r\n\r\n          case 'null':\r\n            return this.node(token, {\r\n              kind: Kind.NULL,\r\n            });\r\n\r\n          default:\r\n            return this.node(token, {\r\n              kind: Kind.ENUM,\r\n              value: token.value,\r\n            });\r\n        }\r\n\r\n      case TokenKind.DOLLAR:\r\n        if (isConst) {\r\n          this.expectToken(TokenKind.DOLLAR);\r\n\r\n          if (this._lexer.token.kind === TokenKind.NAME) {\r\n            const varName = this._lexer.token.value;\r\n            throw syntaxError(\r\n              this._lexer.source,\r\n              token.start,\r\n              `Unexpected variable \"$${varName}\" in constant value.`,\r\n            );\r\n          } else {\r\n            throw this.unexpected(token);\r\n          }\r\n        }\r\n\r\n        return this.parseVariable();\r\n\r\n      default:\r\n        throw this.unexpected();\r\n    }\r\n  }\r\n\r\n  parseConstValueLiteral() {\r\n    return this.parseValueLiteral(true);\r\n  }\r\n\r\n  parseStringLiteral() {\r\n    const token = this._lexer.token;\r\n    this.advanceLexer();\r\n    return this.node(token, {\r\n      kind: Kind.STRING,\r\n      value: token.value,\r\n      block: token.kind === TokenKind.BLOCK_STRING,\r\n    });\r\n  }\r\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\r\n\r\n  parseList(isConst) {\r\n    const item = () => this.parseValueLiteral(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.LIST,\r\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   * ```\r\n   */\r\n\r\n  parseObject(isConst) {\r\n    const item = () => this.parseObjectField(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.OBJECT,\r\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\r\n    });\r\n  }\r\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseObjectField(isConst) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_FIELD,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Directives section.\r\n\r\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\r\n\r\n  parseDirectives(isConst) {\r\n    const directives = [];\r\n\r\n    while (this.peek(TokenKind.AT)) {\r\n      directives.push(this.parseDirective(isConst));\r\n    }\r\n\r\n    return directives;\r\n  }\r\n\r\n  parseConstDirectives() {\r\n    return this.parseDirectives(true);\r\n  }\r\n  /**\r\n   * ```\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   * ```\r\n   */\r\n\r\n  parseDirective(isConst) {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.AT);\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE,\r\n      name: this.parseName(),\r\n      arguments: this.parseArguments(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Types section.\r\n\r\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\r\n\r\n  parseTypeReference() {\r\n    const start = this._lexer.token;\r\n    let type;\r\n\r\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\r\n      const innerType = this.parseTypeReference();\r\n      this.expectToken(TokenKind.BRACKET_R);\r\n      type = this.node(start, {\r\n        kind: Kind.LIST_TYPE,\r\n        type: innerType,\r\n      });\r\n    } else {\r\n      type = this.parseNamedType();\r\n    }\r\n\r\n    if (this.expectOptionalToken(TokenKind.BANG)) {\r\n      return this.node(start, {\r\n        kind: Kind.NON_NULL_TYPE,\r\n        type,\r\n      });\r\n    }\r\n\r\n    return type;\r\n  }\r\n  /**\r\n   * NamedType : Name\r\n   */\r\n\r\n  parseNamedType() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.NAMED_TYPE,\r\n      name: this.parseName(),\r\n    });\r\n  } // Implements the parsing rules in the Type Definition section.\r\n\r\n  peekDescription() {\r\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\r\n  }\r\n  /**\r\n   * Description : StringValue\r\n   */\r\n\r\n  parseDescription() {\r\n    if (this.peekDescription()) {\r\n      return this.parseStringLiteral();\r\n    }\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseSchemaDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.many(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_DEFINITION,\r\n      description,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\r\n\r\n  parseOperationTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const operation = this.parseOperationType();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseNamedType();\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_TYPE_DEFINITION,\r\n      operation,\r\n      type,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\r\n\r\n  parseScalarTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\r\n\r\n  parseImplementsInterfaces() {\r\n    return this.expectOptionalKeyword('implements')\r\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * ```\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseFieldDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\r\n\r\n  parseFieldDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.FIELD_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      type,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\r\n\r\n  parseArgumentDefs() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseInputValueDef() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    let defaultValue;\r\n\r\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\r\n      defaultValue = this.parseConstValueLiteral();\r\n    }\r\n\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      type,\r\n      defaultValue,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseInterfaceTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\r\n\r\n  parseUnionTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\r\n\r\n  parseUnionMemberTypes() {\r\n    return this.expectOptionalToken(TokenKind.EQUALS)\r\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\r\n\r\n  parseEnumTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseEnumValuesDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseEnumValueDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   */\r\n\r\n  parseEnumValueDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseEnumValueName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseEnumValueName() {\r\n    if (\r\n      this._lexer.token.value === 'true' ||\r\n      this._lexer.token.value === 'false' ||\r\n      this._lexer.token.value === 'null'\r\n    ) {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        this._lexer.token.start,\r\n        `${getTokenDesc(\r\n          this._lexer.token,\r\n        )} is reserved and cannot be used for an enum value.`,\r\n      );\r\n    }\r\n\r\n    return this.parseName();\r\n  }\r\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\r\n\r\n  parseInputObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseInputFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseTypeSystemExtension() {\r\n    const keywordToken = this._lexer.lookahead();\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaExtension();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeExtension();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeExtension();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeExtension();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeExtension();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeExtension();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   * ```\r\n   */\r\n\r\n  parseSchemaExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n\r\n    if (directives.length === 0 && operationTypes.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_EXTENSION,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\r\n\r\n  parseScalarTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n\r\n    if (directives.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\r\n\r\n  parseObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\r\n\r\n  parseInterfaceTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\r\n\r\n  parseUnionTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n\r\n    if (directives.length === 0 && types.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\r\n\r\n  parseEnumTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n\r\n    if (directives.length === 0 && values.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\r\n\r\n  parseInputObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n\r\n    if (directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   * ```\r\n   */\r\n\r\n  parseDirectiveDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('directive');\r\n    this.expectToken(TokenKind.AT);\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    const repeatable = this.expectOptionalKeyword('repeatable');\r\n    this.expectKeyword('on');\r\n    const locations = this.parseDirectiveLocations();\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      repeatable,\r\n      locations,\r\n    });\r\n  }\r\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\r\n\r\n  parseDirectiveLocations() {\r\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\r\n  }\r\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\r\n\r\n  parseDirectiveLocation() {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n\r\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\r\n      return name;\r\n    }\r\n\r\n    throw this.unexpected(start);\r\n  } // Core parsing utility functions\r\n\r\n  /**\r\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n   * location object, used to identify the place in the source that created a\r\n   * given parsed object.\r\n   */\r\n\r\n  node(startToken, node) {\r\n    if (this._options.noLocation !== true) {\r\n      node.loc = new Location(\r\n        startToken,\r\n        this._lexer.lastToken,\r\n        this._lexer.source,\r\n      );\r\n    }\r\n\r\n    return node;\r\n  }\r\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\r\n\r\n  peek(kind) {\r\n    return this._lexer.token.kind === kind;\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this.advanceLexer();\r\n      return token;\r\n    }\r\n\r\n    throw syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this.advanceLexer();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this.advanceLexer();\r\n    } else {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        token.start,\r\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this.advanceLexer();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\r\n\r\n  unexpected(atToken) {\r\n    const token =\r\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\r\n    return syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Unexpected ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  any(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    while (!this.expectOptionalToken(closeKind)) {\r\n      nodes.push(parseFn.call(this));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  optionalMany(openKind, parseFn, closeKind) {\r\n    if (this.expectOptionalToken(openKind)) {\r\n      const nodes = [];\r\n\r\n      do {\r\n        nodes.push(parseFn.call(this));\r\n      } while (!this.expectOptionalToken(closeKind));\r\n\r\n      return nodes;\r\n    }\r\n\r\n    return [];\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  many(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (!this.expectOptionalToken(closeKind));\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\r\n\r\n  delimitedMany(delimiterKind, parseFn) {\r\n    this.expectOptionalToken(delimiterKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (this.expectOptionalToken(delimiterKind));\r\n\r\n    return nodes;\r\n  }\r\n\r\n  advanceLexer() {\r\n    const { maxTokens } = this._options;\r\n\r\n    const token = this._lexer.advance();\r\n\r\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\r\n      ++this._tokenCounter;\r\n\r\n      if (this._tokenCounter > maxTokens) {\r\n        throw syntaxError(\r\n          this._lexer.source,\r\n          token.start,\r\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\r\n\r\nfunction getTokenDesc(token) {\r\n  const value = token.value;\r\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\r\n}\r\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\r\n\r\nfunction getTokenKindDesc(kind) {\r\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}