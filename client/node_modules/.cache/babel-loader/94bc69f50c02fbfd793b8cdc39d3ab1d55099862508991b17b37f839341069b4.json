{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext.mjs';\n/**\r\n * Implements the \"Validation\" section of the spec.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the document is valid.\r\n *\r\n * A list of specific validation rules may be provided. If not provided, the\r\n * default list of rules defined by the GraphQL specification will be used.\r\n *\r\n * Each validation rules is a function which returns a visitor\r\n * (see the language/visitor API). Visitor methods are expected to return\r\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\r\n *\r\n * Validate will stop validation after a `maxErrors` limit has been reached.\r\n * Attackers can send pathologically invalid queries to induce a DoS attack,\r\n * so by default `maxErrors` set to 100 errors.\r\n *\r\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\r\n * will be created from the provided schema.\r\n */\n\nexport function validate(schema, documentAST) {\n  let rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let typeInfo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new TypeInfo(schema);\n  var _options$maxErrors;\n  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(schema, documentAST, typeInfo, error => {\n    if (errors.length >= maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.')); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n      throw abortObj;\n    }\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map(rule => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n  return errors;\n}\n/**\r\n * @internal\r\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  let rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  const errors = [];\n  const context = new SDLValidationContext(documentAST, schemaToExtend, error => {\n    errors.push(error);\n  });\n  const visitors = rules.map(rule => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}","map":{"version":3,"names":["devAssert","GraphQLError","visit","visitInParallel","assertValidSchema","TypeInfo","visitWithTypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","validate","schema","documentAST","rules","arguments","length","undefined","options","typeInfo","_options$maxErrors","maxErrors","abortObj","Object","freeze","errors","context","error","push","visitor","map","rule","e","validateSDL","schemaToExtend","visitors","assertValidSDL","Error","message","join","assertValidSDLExtension"],"sources":["C:/Users/Daniel Gregoire/Desktop/ucf-bootcamp/perfect-parlay/client/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { GraphQLError } from '../error/GraphQLError.mjs';\r\nimport { visit, visitInParallel } from '../language/visitor.mjs';\r\nimport { assertValidSchema } from '../type/validate.mjs';\r\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\r\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\r\nimport {\r\n  SDLValidationContext,\r\n  ValidationContext,\r\n} from './ValidationContext.mjs';\r\n/**\r\n * Implements the \"Validation\" section of the spec.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the document is valid.\r\n *\r\n * A list of specific validation rules may be provided. If not provided, the\r\n * default list of rules defined by the GraphQL specification will be used.\r\n *\r\n * Each validation rules is a function which returns a visitor\r\n * (see the language/visitor API). Visitor methods are expected to return\r\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\r\n *\r\n * Validate will stop validation after a `maxErrors` limit has been reached.\r\n * Attackers can send pathologically invalid queries to induce a DoS attack,\r\n * so by default `maxErrors` set to 100 errors.\r\n *\r\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\r\n * will be created from the provided schema.\r\n */\r\n\r\nexport function validate(\r\n  schema,\r\n  documentAST,\r\n  rules = specifiedRules,\r\n  options,\r\n  /** @deprecated will be removed in 17.0.0 */\r\n  typeInfo = new TypeInfo(schema),\r\n) {\r\n  var _options$maxErrors;\r\n\r\n  const maxErrors =\r\n    (_options$maxErrors =\r\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\r\n      null && _options$maxErrors !== void 0\r\n      ? _options$maxErrors\r\n      : 100;\r\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\r\n\r\n  assertValidSchema(schema);\r\n  const abortObj = Object.freeze({});\r\n  const errors = [];\r\n  const context = new ValidationContext(\r\n    schema,\r\n    documentAST,\r\n    typeInfo,\r\n    (error) => {\r\n      if (errors.length >= maxErrors) {\r\n        errors.push(\r\n          new GraphQLError(\r\n            'Too many validation errors, error limit reached. Validation aborted.',\r\n          ),\r\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n\r\n        throw abortObj;\r\n      }\r\n\r\n      errors.push(error);\r\n    },\r\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\r\n  // while maintaining the visitor skip and break API.\r\n\r\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\r\n\r\n  try {\r\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\r\n  } catch (e) {\r\n    if (e !== abortObj) {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  return errors;\r\n}\r\n/**\r\n * @internal\r\n */\r\n\r\nexport function validateSDL(\r\n  documentAST,\r\n  schemaToExtend,\r\n  rules = specifiedSDLRules,\r\n) {\r\n  const errors = [];\r\n  const context = new SDLValidationContext(\r\n    documentAST,\r\n    schemaToExtend,\r\n    (error) => {\r\n      errors.push(error);\r\n    },\r\n  );\r\n  const visitors = rules.map((rule) => rule(context));\r\n  visit(documentAST, visitInParallel(visitors));\r\n  return errors;\r\n}\r\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function assertValidSDL(documentAST) {\r\n  const errors = validateSDL(documentAST);\r\n\r\n  if (errors.length !== 0) {\r\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\r\n  }\r\n}\r\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function assertValidSDLExtension(documentAST, schema) {\r\n  const errors = validateSDL(documentAST, schema);\r\n\r\n  if (errors.length !== 0) {\r\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}