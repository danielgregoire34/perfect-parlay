{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { isEnumType, isInputObjectType, isInputType, isInterfaceType, isNamedType, isNonNullType, isObjectType, isOutputType, isRequiredArgument, isRequiredInputField, isUnionType } from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\r\n * Implements the \"Type Validation\" sub-sections of the specification's\r\n * \"Type System\" section.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the Schema is valid.\r\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\r\n * Utility function which asserts a schema is valid by throwing an error if\r\n * it is invalid.\r\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n    this._errors.push(new GraphQLError(message, {\n      nodes: _nodes\n    }));\n  }\n  getErrors() {\n    return this._errors;\n  }\n}\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  schemaNode => {\n    var _schemaNode$operation;\n    return (/* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);\n      }\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n  const includedTypeNames = Object.create(null);\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!isObjectType(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n    return (/* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n    return (/* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","isEnumType","isInputObjectType","isInputType","isInterfaceType","isNamedType","isNonNullType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isUnionType","GraphQLDeprecatedDirective","isDirective","isIntrospectionType","assertSchema","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","astNode","_getOperationTypeNode","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","validateName","arg","args","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","field","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"sources":["C:/Users/Daniel Gregoire/Desktop/ucf-bootcamp/perfect-parlay/client/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\r\nimport { GraphQLError } from '../error/GraphQLError.mjs';\r\nimport { OperationTypeNode } from '../language/ast.mjs';\r\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\r\nimport {\r\n  isEnumType,\r\n  isInputObjectType,\r\n  isInputType,\r\n  isInterfaceType,\r\n  isNamedType,\r\n  isNonNullType,\r\n  isObjectType,\r\n  isOutputType,\r\n  isRequiredArgument,\r\n  isRequiredInputField,\r\n  isUnionType,\r\n} from './definition.mjs';\r\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\r\nimport { isIntrospectionType } from './introspection.mjs';\r\nimport { assertSchema } from './schema.mjs';\r\n/**\r\n * Implements the \"Type Validation\" sub-sections of the specification's\r\n * \"Type System\" section.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the Schema is valid.\r\n */\r\n\r\nexport function validateSchema(schema) {\r\n  // First check to ensure the provided value is in fact a GraphQLSchema.\r\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\r\n\r\n  if (schema.__validationErrors) {\r\n    return schema.__validationErrors;\r\n  } // Validate the schema, producing a list of errors.\r\n\r\n  const context = new SchemaValidationContext(schema);\r\n  validateRootTypes(context);\r\n  validateDirectives(context);\r\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\r\n  // does not run multiple times for this schema.\r\n\r\n  const errors = context.getErrors();\r\n  schema.__validationErrors = errors;\r\n  return errors;\r\n}\r\n/**\r\n * Utility function which asserts a schema is valid by throwing an error if\r\n * it is invalid.\r\n */\r\n\r\nexport function assertValidSchema(schema) {\r\n  const errors = validateSchema(schema);\r\n\r\n  if (errors.length !== 0) {\r\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\r\n  }\r\n}\r\n\r\nclass SchemaValidationContext {\r\n  constructor(schema) {\r\n    this._errors = [];\r\n    this.schema = schema;\r\n  }\r\n\r\n  reportError(message, nodes) {\r\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\r\n\r\n    this._errors.push(\r\n      new GraphQLError(message, {\r\n        nodes: _nodes,\r\n      }),\r\n    );\r\n  }\r\n\r\n  getErrors() {\r\n    return this._errors;\r\n  }\r\n}\r\n\r\nfunction validateRootTypes(context) {\r\n  const schema = context.schema;\r\n  const queryType = schema.getQueryType();\r\n\r\n  if (!queryType) {\r\n    context.reportError('Query root type must be provided.', schema.astNode);\r\n  } else if (!isObjectType(queryType)) {\r\n    var _getOperationTypeNode;\r\n\r\n    context.reportError(\r\n      `Query root type must be Object type, it cannot be ${inspect(\r\n        queryType,\r\n      )}.`,\r\n      (_getOperationTypeNode = getOperationTypeNode(\r\n        schema,\r\n        OperationTypeNode.QUERY,\r\n      )) !== null && _getOperationTypeNode !== void 0\r\n        ? _getOperationTypeNode\r\n        : queryType.astNode,\r\n    );\r\n  }\r\n\r\n  const mutationType = schema.getMutationType();\r\n\r\n  if (mutationType && !isObjectType(mutationType)) {\r\n    var _getOperationTypeNode2;\r\n\r\n    context.reportError(\r\n      'Mutation root type must be Object type if provided, it cannot be ' +\r\n        `${inspect(mutationType)}.`,\r\n      (_getOperationTypeNode2 = getOperationTypeNode(\r\n        schema,\r\n        OperationTypeNode.MUTATION,\r\n      )) !== null && _getOperationTypeNode2 !== void 0\r\n        ? _getOperationTypeNode2\r\n        : mutationType.astNode,\r\n    );\r\n  }\r\n\r\n  const subscriptionType = schema.getSubscriptionType();\r\n\r\n  if (subscriptionType && !isObjectType(subscriptionType)) {\r\n    var _getOperationTypeNode3;\r\n\r\n    context.reportError(\r\n      'Subscription root type must be Object type if provided, it cannot be ' +\r\n        `${inspect(subscriptionType)}.`,\r\n      (_getOperationTypeNode3 = getOperationTypeNode(\r\n        schema,\r\n        OperationTypeNode.SUBSCRIPTION,\r\n      )) !== null && _getOperationTypeNode3 !== void 0\r\n        ? _getOperationTypeNode3\r\n        : subscriptionType.astNode,\r\n    );\r\n  }\r\n}\r\n\r\nfunction getOperationTypeNode(schema, operation) {\r\n  var _flatMap$find;\r\n\r\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\r\n    .flatMap(\r\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\r\n      (schemaNode) => {\r\n        var _schemaNode$operation;\r\n\r\n        return (\r\n          /* c8 ignore next */\r\n          (_schemaNode$operation =\r\n            schemaNode === null || schemaNode === void 0\r\n              ? void 0\r\n              : schemaNode.operationTypes) !== null &&\r\n            _schemaNode$operation !== void 0\r\n            ? _schemaNode$operation\r\n            : []\r\n        );\r\n      },\r\n    )\r\n    .find((operationNode) => operationNode.operation === operation)) === null ||\r\n    _flatMap$find === void 0\r\n    ? void 0\r\n    : _flatMap$find.type;\r\n}\r\n\r\nfunction validateDirectives(context) {\r\n  for (const directive of context.schema.getDirectives()) {\r\n    // Ensure all directives are in fact GraphQL directives.\r\n    if (!isDirective(directive)) {\r\n      context.reportError(\r\n        `Expected directive but got: ${inspect(directive)}.`,\r\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\r\n      );\r\n      continue;\r\n    } // Ensure they are named correctly.\r\n\r\n    validateName(context, directive); // TODO: Ensure proper locations.\r\n    // Ensure the arguments are valid.\r\n\r\n    for (const arg of directive.args) {\r\n      // Ensure they are named correctly.\r\n      validateName(context, arg); // Ensure the type is an input type.\r\n\r\n      if (!isInputType(arg.type)) {\r\n        context.reportError(\r\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\r\n            `but got: ${inspect(arg.type)}.`,\r\n          arg.astNode,\r\n        );\r\n      }\r\n\r\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\r\n        var _arg$astNode;\r\n\r\n        context.reportError(\r\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\r\n          [\r\n            getDeprecatedDirectiveNode(arg.astNode),\r\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\r\n              ? void 0\r\n              : _arg$astNode.type,\r\n          ],\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateName(context, node) {\r\n  // Ensure names are valid, however introspection types opt out.\r\n  if (node.name.startsWith('__')) {\r\n    context.reportError(\r\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\r\n      node.astNode,\r\n    );\r\n  }\r\n}\r\n\r\nfunction validateTypes(context) {\r\n  const validateInputObjectCircularRefs =\r\n    createInputObjectCircularRefsValidator(context);\r\n  const typeMap = context.schema.getTypeMap();\r\n\r\n  for (const type of Object.values(typeMap)) {\r\n    // Ensure all provided types are in fact GraphQL type.\r\n    if (!isNamedType(type)) {\r\n      context.reportError(\r\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\r\n        type.astNode,\r\n      );\r\n      continue;\r\n    } // Ensure it is named correctly (excluding introspection types).\r\n\r\n    if (!isIntrospectionType(type)) {\r\n      validateName(context, type);\r\n    }\r\n\r\n    if (isObjectType(type)) {\r\n      // Ensure fields are valid\r\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\r\n\r\n      validateInterfaces(context, type);\r\n    } else if (isInterfaceType(type)) {\r\n      // Ensure fields are valid.\r\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\r\n\r\n      validateInterfaces(context, type);\r\n    } else if (isUnionType(type)) {\r\n      // Ensure Unions include valid member types.\r\n      validateUnionMembers(context, type);\r\n    } else if (isEnumType(type)) {\r\n      // Ensure Enums have valid values.\r\n      validateEnumValues(context, type);\r\n    } else if (isInputObjectType(type)) {\r\n      // Ensure Input Object fields are valid.\r\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\r\n\r\n      validateInputObjectCircularRefs(type);\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateFields(context, type) {\r\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\r\n\r\n  if (fields.length === 0) {\r\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\r\n      type.astNode,\r\n      ...type.extensionASTNodes,\r\n    ]);\r\n  }\r\n\r\n  for (const field of fields) {\r\n    // Ensure they are named correctly.\r\n    validateName(context, field); // Ensure the type is an output type\r\n\r\n    if (!isOutputType(field.type)) {\r\n      var _field$astNode;\r\n\r\n      context.reportError(\r\n        `The type of ${type.name}.${field.name} must be Output Type ` +\r\n          `but got: ${inspect(field.type)}.`,\r\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\r\n          ? void 0\r\n          : _field$astNode.type,\r\n      );\r\n    } // Ensure the arguments are valid\r\n\r\n    for (const arg of field.args) {\r\n      const argName = arg.name; // Ensure they are named correctly.\r\n\r\n      validateName(context, arg); // Ensure the type is an input type\r\n\r\n      if (!isInputType(arg.type)) {\r\n        var _arg$astNode2;\r\n\r\n        context.reportError(\r\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\r\n            `Type but got: ${inspect(arg.type)}.`,\r\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\r\n            ? void 0\r\n            : _arg$astNode2.type,\r\n        );\r\n      }\r\n\r\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\r\n        var _arg$astNode3;\r\n\r\n        context.reportError(\r\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\r\n          [\r\n            getDeprecatedDirectiveNode(arg.astNode),\r\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\r\n              ? void 0\r\n              : _arg$astNode3.type,\r\n          ],\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateInterfaces(context, type) {\r\n  const ifaceTypeNames = Object.create(null);\r\n\r\n  for (const iface of type.getInterfaces()) {\r\n    if (!isInterfaceType(iface)) {\r\n      context.reportError(\r\n        `Type ${inspect(type)} must only implement Interface types, ` +\r\n          `it cannot implement ${inspect(iface)}.`,\r\n        getAllImplementsInterfaceNodes(type, iface),\r\n      );\r\n      continue;\r\n    }\r\n\r\n    if (type === iface) {\r\n      context.reportError(\r\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\r\n        getAllImplementsInterfaceNodes(type, iface),\r\n      );\r\n      continue;\r\n    }\r\n\r\n    if (ifaceTypeNames[iface.name]) {\r\n      context.reportError(\r\n        `Type ${type.name} can only implement ${iface.name} once.`,\r\n        getAllImplementsInterfaceNodes(type, iface),\r\n      );\r\n      continue;\r\n    }\r\n\r\n    ifaceTypeNames[iface.name] = true;\r\n    validateTypeImplementsAncestors(context, type, iface);\r\n    validateTypeImplementsInterface(context, type, iface);\r\n  }\r\n}\r\n\r\nfunction validateTypeImplementsInterface(context, type, iface) {\r\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\r\n\r\n  for (const ifaceField of Object.values(iface.getFields())) {\r\n    const fieldName = ifaceField.name;\r\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\r\n\r\n    if (!typeField) {\r\n      context.reportError(\r\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\r\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\r\n      );\r\n      continue;\r\n    } // Assert interface field type is satisfied by type field type, by being\r\n    // a valid subtype. (covariant)\r\n\r\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\r\n      var _ifaceField$astNode, _typeField$astNode;\r\n\r\n      context.reportError(\r\n        `Interface field ${iface.name}.${fieldName} expects type ` +\r\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\r\n          `is type ${inspect(typeField.type)}.`,\r\n        [\r\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\r\n          _ifaceField$astNode === void 0\r\n            ? void 0\r\n            : _ifaceField$astNode.type,\r\n          (_typeField$astNode = typeField.astNode) === null ||\r\n          _typeField$astNode === void 0\r\n            ? void 0\r\n            : _typeField$astNode.type,\r\n        ],\r\n      );\r\n    } // Assert each interface field arg is implemented.\r\n\r\n    for (const ifaceArg of ifaceField.args) {\r\n      const argName = ifaceArg.name;\r\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\r\n\r\n      if (!typeArg) {\r\n        context.reportError(\r\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\r\n          [ifaceArg.astNode, typeField.astNode],\r\n        );\r\n        continue;\r\n      } // Assert interface field arg type matches object field arg type.\r\n      // (invariant)\r\n      // TODO: change to contravariant?\r\n\r\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\r\n        var _ifaceArg$astNode, _typeArg$astNode;\r\n\r\n        context.reportError(\r\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\r\n            `expects type ${inspect(ifaceArg.type)} but ` +\r\n            `${type.name}.${fieldName}(${argName}:) is type ` +\r\n            `${inspect(typeArg.type)}.`,\r\n          [\r\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\r\n            _ifaceArg$astNode === void 0\r\n              ? void 0\r\n              : _ifaceArg$astNode.type,\r\n            (_typeArg$astNode = typeArg.astNode) === null ||\r\n            _typeArg$astNode === void 0\r\n              ? void 0\r\n              : _typeArg$astNode.type,\r\n          ],\r\n        );\r\n      } // TODO: validate default values?\r\n    } // Assert additional arguments must not be required.\r\n\r\n    for (const typeArg of typeField.args) {\r\n      const argName = typeArg.name;\r\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\r\n\r\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\r\n        context.reportError(\r\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\r\n          [typeArg.astNode, ifaceField.astNode],\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateTypeImplementsAncestors(context, type, iface) {\r\n  const ifaceInterfaces = type.getInterfaces();\r\n\r\n  for (const transitive of iface.getInterfaces()) {\r\n    if (!ifaceInterfaces.includes(transitive)) {\r\n      context.reportError(\r\n        transitive === type\r\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\r\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\r\n        [\r\n          ...getAllImplementsInterfaceNodes(iface, transitive),\r\n          ...getAllImplementsInterfaceNodes(type, iface),\r\n        ],\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateUnionMembers(context, union) {\r\n  const memberTypes = union.getTypes();\r\n\r\n  if (memberTypes.length === 0) {\r\n    context.reportError(\r\n      `Union type ${union.name} must define one or more member types.`,\r\n      [union.astNode, ...union.extensionASTNodes],\r\n    );\r\n  }\r\n\r\n  const includedTypeNames = Object.create(null);\r\n\r\n  for (const memberType of memberTypes) {\r\n    if (includedTypeNames[memberType.name]) {\r\n      context.reportError(\r\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\r\n        getUnionMemberTypeNodes(union, memberType.name),\r\n      );\r\n      continue;\r\n    }\r\n\r\n    includedTypeNames[memberType.name] = true;\r\n\r\n    if (!isObjectType(memberType)) {\r\n      context.reportError(\r\n        `Union type ${union.name} can only include Object types, ` +\r\n          `it cannot include ${inspect(memberType)}.`,\r\n        getUnionMemberTypeNodes(union, String(memberType)),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateEnumValues(context, enumType) {\r\n  const enumValues = enumType.getValues();\r\n\r\n  if (enumValues.length === 0) {\r\n    context.reportError(\r\n      `Enum type ${enumType.name} must define one or more values.`,\r\n      [enumType.astNode, ...enumType.extensionASTNodes],\r\n    );\r\n  }\r\n\r\n  for (const enumValue of enumValues) {\r\n    // Ensure valid name.\r\n    validateName(context, enumValue);\r\n  }\r\n}\r\n\r\nfunction validateInputFields(context, inputObj) {\r\n  const fields = Object.values(inputObj.getFields());\r\n\r\n  if (fields.length === 0) {\r\n    context.reportError(\r\n      `Input Object type ${inputObj.name} must define one or more fields.`,\r\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\r\n    );\r\n  } // Ensure the arguments are valid\r\n\r\n  for (const field of fields) {\r\n    // Ensure they are named correctly.\r\n    validateName(context, field); // Ensure the type is an input type\r\n\r\n    if (!isInputType(field.type)) {\r\n      var _field$astNode2;\r\n\r\n      context.reportError(\r\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\r\n          `but got: ${inspect(field.type)}.`,\r\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\r\n          ? void 0\r\n          : _field$astNode2.type,\r\n      );\r\n    }\r\n\r\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\r\n      var _field$astNode3;\r\n\r\n      context.reportError(\r\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\r\n        [\r\n          getDeprecatedDirectiveNode(field.astNode),\r\n          (_field$astNode3 = field.astNode) === null ||\r\n          _field$astNode3 === void 0\r\n            ? void 0\r\n            : _field$astNode3.type,\r\n        ],\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction createInputObjectCircularRefsValidator(context) {\r\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\r\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\r\n  // are not redundantly reported.\r\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\r\n\r\n  const fieldPath = []; // Position in the type path\r\n\r\n  const fieldPathIndexByTypeName = Object.create(null);\r\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\r\n  // It does not terminate when a cycle was found but continues to explore\r\n  // the graph to find all possible cycles.\r\n\r\n  function detectCycleRecursive(inputObj) {\r\n    if (visitedTypes[inputObj.name]) {\r\n      return;\r\n    }\r\n\r\n    visitedTypes[inputObj.name] = true;\r\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\r\n    const fields = Object.values(inputObj.getFields());\r\n\r\n    for (const field of fields) {\r\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\r\n        const fieldType = field.type.ofType;\r\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\r\n        fieldPath.push(field);\r\n\r\n        if (cycleIndex === undefined) {\r\n          detectCycleRecursive(fieldType);\r\n        } else {\r\n          const cyclePath = fieldPath.slice(cycleIndex);\r\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\r\n          context.reportError(\r\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\r\n            cyclePath.map((fieldObj) => fieldObj.astNode),\r\n          );\r\n        }\r\n\r\n        fieldPath.pop();\r\n      }\r\n    }\r\n\r\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\r\n  }\r\n}\r\n\r\nfunction getAllImplementsInterfaceNodes(type, iface) {\r\n  const { astNode, extensionASTNodes } = type;\r\n  const nodes =\r\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\r\n\r\n  return nodes\r\n    .flatMap((typeNode) => {\r\n      var _typeNode$interfaces;\r\n\r\n      return (\r\n        /* c8 ignore next */\r\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\r\n          _typeNode$interfaces !== void 0\r\n          ? _typeNode$interfaces\r\n          : []\r\n      );\r\n    })\r\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\r\n}\r\n\r\nfunction getUnionMemberTypeNodes(union, typeName) {\r\n  const { astNode, extensionASTNodes } = union;\r\n  const nodes =\r\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\r\n\r\n  return nodes\r\n    .flatMap((unionNode) => {\r\n      var _unionNode$types;\r\n\r\n      return (\r\n        /* c8 ignore next */\r\n        (_unionNode$types = unionNode.types) !== null &&\r\n          _unionNode$types !== void 0\r\n          ? _unionNode$types\r\n          : []\r\n      );\r\n    })\r\n    .filter((typeNode) => typeNode.name.value === typeName);\r\n}\r\n\r\nfunction getDeprecatedDirectiveNode(definitionNode) {\r\n  var _definitionNode$direc;\r\n\r\n  return definitionNode === null || definitionNode === void 0\r\n    ? void 0\r\n    : (_definitionNode$direc = definitionNode.directives) === null ||\r\n      _definitionNode$direc === void 0\r\n    ? void 0\r\n    : _definitionNode$direc.find(\r\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\r\n      );\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}